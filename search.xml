<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多情应笑我，早生华发]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%A4%9A%E6%83%85%E5%BA%94%E7%AC%91%E6%88%91%2F</url>
    <content type="text"><![CDATA[念奴娇·赤壁怀古 苏轼 大江东去，浪淘尽，千古风流人物。 故垒西边，人道是，三国周郎赤壁。 乱石穿空，惊涛拍岸，卷起千堆雪。 江山如画，一时多少豪杰。 遥想公瑾当年，小乔初嫁了，雄姿英发。 羽扇纶巾，谈笑间，樯橹灰飞烟灭。 故国神游，多情应笑我，早生华发。 人生如梦，一尊还酹江月。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天是五月二十号]]></title>
    <url>%2F2019%2F05%2F20%2F%E4%BB%8A%E5%A4%A9%E6%98%AF%E4%BA%94%E6%9C%88%E4%BA%8C%E5%8D%81%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[今天是五月二十号在这个不冷不热的五月，今年已将近过半，前天开始进入了生命的第三轮的旅程，不知道是从什么时候开始，害怕家人突然的关心，害怕他们对我的感情生活的关心和打听。 我理解他们对我的焦虑，可是他们不懂我的迷茫啊，我不想过那种没有希望的生活，我觉得自己还没有足够的能力，去许诺另一个人的未来，我不想做没有把握的承诺。我爸跟我讲过，说有两个人一起奋斗会更好。从小就是一个人自立自强的我不敢相信有这种人存在，所以我直接回答，现在这个社会不是你们那时候了，那种纯真纯正的感情是现在这个快餐式爱情社会的极度奢侈品吧。 什么是快餐式爱情？我的大致理解就是，在网上看过几次照片，聊过几次语音，如此尔尔，就宣布“爱了”，真的是快乐就完事了。 我保存着相信，我更保持着理性！ 还有朋友分享他的感情生活，比如相亲等等话题了，我始终保持祝福，也始终相信，好的人也终遇良人，一定会美满幸福。我的态度是，虽然有点羡慕有人那么幸运能够在生命很早的时候就遇到对的人，但是我并不“酸”，因为相信这是上天最好的安排。或你，或他，既是如此。 我虽是感性的人，但理性始终大于感性。 最后，我为啥会写这个文章呢，是因为我想维护一下我的网站了，好久没有弄我的 hexo 了，之前将它放到自己的服务器了，还有诸多不良之处，等慢慢修改吧。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a标签的妙用]]></title>
    <url>%2F2019%2F04%2F18%2Fa%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[a 标签的妙用最近写了一个静态页面的项目，发现 a 标签在手机端的一些其他的用途，为自己做一个总结 1、a 标签可以直接拨打电话 1、这里最常用的是用tel 来调用拨打电话的功能，属于 H5 的一些特性 1&lt;a href="tel:10086"&gt;10086&lt;/a&gt; //点击后直接拨打10086 如果要支持 safari for ios ，blackberry browser 的号码，需要加上一下标签，目的是自动探测电话号码 1234&lt;meta name="format-detection" content="telephone=no" /&gt;&lt;meta http-equiv="x-rim-auto-match" content="none"/&gt; 2、使用 wtai 协议进行拨打电话。 在 wml 中可以调用设备的 wtai 函数来呼叫特定的电话号码。目前，越来越多的浏览器都支持这个功能，但还不是所有。 123＜input name="phone_no" format="*m" value="13"/＞ ＜do type="option"label="呼出号"＞ ＜go href="wtai://wp/mc;$(phone_no)"/＞ ＜/do＞＜br/＞ //或者直接写入电话号码的方式： ＜a href="wtai://wp/mc;1331597312*"＞拨打电话＜/a＞ 另一种方式是这么写的 1&lt;a href="dc:5040*0077"&gt;拨打热线&lt;/a&gt; 2、a 标签发邮件这里我只用到了这种写法 12&lt;a href="mailto:test@qq.com?subject=TestObject"&gt;c6088@qq.com&lt;/a&gt;//点击后直接给c1586@qq.com发邮件，主题为：TestObject 3、a 标签发短信这里我只用到了这种写法 12&lt;a href="sms:10086?body=message_body"&gt;给 10086 发短信&lt;/a&gt;//点击后直接给10086发信息，消息内容默认为message_body 4、a 标签定位置（调用地图）这个我没有写,相比其他的几个功能,这个更麻烦吧,我没有实际使用 123&lt;a href="geopoint:116.281469,39.866035"&gt;我的位置&lt;/a&gt; //点击后直接发送自己的位置&lt;a href="geopoint:经度,纬度"&gt;我的位置&lt;/a&gt;// 这个直接搜索一些当前需要定位置的坐标就好了 3、a 标签当做下载链接这里我只用到了这种写法 1234&lt;a href="img/aa.png" download="WC.png"&gt;点击下载链接&lt;/a&gt;//href中只需要放上图片的链接，其实就是放需要下载的资源可以是zip，doc等等，不限文件的,如下面这种写法&lt;a href="content/test.zip" download="test.zip"&gt;点击下载链接&lt;/a&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>a标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库索引]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[数据库索引 索引的原理 要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是b tree或者b+ tree，重要的事情说三遍：“平衡树，平衡树，平衡树”， 当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的 RDBMS 都是把平衡树当做数据表默认的索引数据结构的 索引的直观感受 索引会提升查询数据库的速度，但是在访问量大，高并发的情况下，会导致写入数据时性能下降（其实是对数据的增删改都会变慢） 1、为什么要给表加上主键？ 平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。 建索引的缺点 每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。 文章上面的内容已经指出， 当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。 2、为什么加索引后会使查询变快？假如一张表有一亿条数据 ，需要查找其中某一条数据，按照常规逻辑， 一条一条的去匹配的话， 最坏的情况下需要匹配一亿次才能得到结果，用大 O 标记法就是 O(n)最坏时间复杂度，这是无法接受的，而且这一亿条数据显然不能一次性读入内存供程序使用， 因此， 这一亿次匹配在不经缓存优化的情况下就是一亿次 IO 开销，以现在磁盘的 IO 能力和 CPU 的运算能力， 有可能需要几个月才能得出结果 。如果把这张表转换成平衡树结构（一棵非常茂盛和节点非常多的树），假设这棵树有 10 层，那么只需要 10 次 IO 开销就能查找到所需要的数据， 速度以指数级别提升，用大 O 标记法就是 O(log n)，n 是记录总树，底数是树的分叉数，结果就是树的层次数。换言之，查找次数是以树的分叉数为底，记录总数的对数，用公式来表示就是用程序来表示就是 Math.Log(100000000,10)，100000000 是记录数，10 是树的分叉数（真实环境下分叉数远不止 10）， 结果就是查找次数，这里的结果从亿降到了个位数。因此，利用索引会使数据库查询有惊人的性能提升。 3、为什么加索引后会使写入、修改、删除变慢？ 每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构，因此，在每次数据改变时， DBMS 必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。 4、什么情况下要同时在两个字段上建索引？ 待补充 5、聚集索引和非聚集索引？ 「聚集索引」 如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。 「非聚集索引」 非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给 user 表的 name 字段加上索引 ， 那么索引就是由 name 字段中的值构成，在数据改变时， DBMS 需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。 非聚集索引和聚集索引的区别 聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径 然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。 文章上面的内容已经指出， 当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中 索引的查询过程 123//建立索引create index index_birthday on user_info(birthday);//查询生日在1991年11月1日出生用户的用户名select user_name from user_info where birthday = &apos;1991-11-1&apos; 这句 SQL 语句的执行过程如下首先，通过非聚集索引index_birthday查找birthday等于 1991-11-1 的所有记录的主键 ID 值然后，通过得到的主键 ID 值执行聚集索引查找，找到主键 ID 值对就的真实数据（数据行）存储的位置最后， 从得到的真实数据中取得 user_name 字段的值返回， 也就是取得最终的结果我们把 birthday 字段上的索引改成双字段的覆盖索引 1create index index_birthday_and_user_name on user_info(birthday, user_name); 这句 SQL 语句的执行过程就会变为通过非聚集索引index_birthday_and_user_name查找birthday等于 1991-11-1 的叶节点的内容，然而， 叶节点中除了有 user_name 表主键 ID 的值以外， user_name 字段的值也在里面， 因此不需要通过主键 ID 值的查找数据行的真实所在， 直接取得叶节点中 user_name 的值返回即可。 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能，如下图! 什么时候需要建索引(来源于百度知道) 1、表的主键、外键必须有索引；2、数据量超过 300 的表应该有索引；3、经常与其他表进行连接的表，在连接字段上应该建立索引；4、经常出现在 Where 子句中的字段，特别是大表的字段，应该建立索引；5、索引应该建在选择性高的字段上；6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替： A、正确选择复合索引中的主列字段，一般是选择性较好的字段；B、复合索引的几个字段是否经常同时以 AND 方式出现在 Where 子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；C、如果复合索引中包含的字段经常单独出现在 Where 子句中，则分解为多个单字段索引；D、如果复合索引所包含的字段超过 3 个，那么仔细考虑其必要性，考虑减少复合的字段；E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； 8、频繁进行数据操作的表，不要建立太多的索引；9、删除无用的索引，避免对执行计划造成负面影响；以上是一些普遍的建立索引时的判断依据。一言以蔽之，索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 总得来讲：当修改性能远远大于检索心梗时，不应该创建索引]]></content>
  </entry>
  <entry>
    <title><![CDATA[单例模式的微总结]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 单例模式 什么是单例模式？ 单例模式是指确保一个类只有一个实例，提供一个全局访问点，不需要实例化这个类，直接调用其方法即可 1、具体步骤是1、将类的构造函数生命为私有的构造函数，在外部就不能通过Test a= new Test()来实例化，用Private字段限制只能在内部可以实例，外部不能访问。2、在类的里面声明一个用static修饰的公开的全局静态字段（这里就是提供给外部的唯一访问点），外部可以通过这个访问点，拿到该类的实例，static表示是静态变量，会长期占用内存，别人能够直接拿到实例 2、什么时候需要使用单例模式： 虽然使用单例模式是直接调用该类，但会长期占用内存，不会被销毁，这既是优点也是缺点，切不可为图方便就大量的使用单例 1、在系统中有不可变的参数，或者需要记录保持叠加的参数 2、为避免重复或者冲突的业务场景，需要使用单线程工作完成的场景就需要适当使用单例模式，比如：打印机业务，或者 windows 操作系统中的打开文件和桌面右键刷新都是单例模式的使用场景 3、单例模式的两种方式懒加载方式： 指的是只有在有调用这个唯一访问点的时候才去实例化该类，当有多人调用的时候，也只有第一次调用的时候会实例化，全局只实例化一次。饿汉模式加载方式： 指的是系统初始化的时候就已经实例化好了类，外部调不调用都在那里。 总结： 在合适的场景使用单例模式，不要无节制的使用，会导致内存占用过多，甚至内存泄露等，也就是：尽量避免静态成员的使用，因为静态成员所在的实例，不会被 GC 回收 优先选择静态方法调用而不是单例模式调用 在单例模式中尽量使用懒加载的方式，而不是饿汉加载的方式，减少程序启动成本。 12345678910111213141516171819202122232425262728293031323334/// 定义一个私有类private void SingleInstance() &#123;// 这里是处理逻辑&#125;/// 实例化 饿汉模式加载private static SingleInstance _instance = new SingleInstance();/// 提供全局唯一访问点 public static SingleInstance GetInstance（）&#123; return _instance; &#125;/// 实例化 懒加载private static SingleInstance _instance = new SingleInstance(); //这里顺便使用了lock(object)来锁定一个变量，达到加锁的目的，避免多个线程同时对实例执行初始化。那么如果我们lock(string 字符串类型)是否可以呢？答案是否定。 private static readonly object _lock = new object();/// 提供全局唯一访问点 public static SingleInstance GetInstance()&#123; if (_instance == null) &#123; lock (_lock) &#123; if (_instance == null) &#123; _instance = new SingleInstance(); &#125; &#125; &#125; return _instance;&#125; 本文参考了博客园的文章，侵权联系删除 查看原文]]></content>
  </entry>
  <entry>
    <title><![CDATA[云烟成雨]]></title>
    <url>%2F2019%2F04%2F07%2F%E4%BA%91%E7%83%9F%E6%88%90%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[你的晚安 是下意识的恻隐 我留至夜深 治疗失眠梦呓 那封手写信 留在行李箱底 来不及 赋予它旅途的意义 若一切 都已云烟成雨 我能否 变成淤泥 再一次 沾染你 若生命 如过场电影 Oh 让我再一次 甜梦里惊醒 我多想再见你 哪怕匆匆一眼就别离 路灯下昏黄的剪影 越走越漫长的林径 我多想再见你 至少玩笑话还能说起 街巷初次落叶的秋分 渐行渐远去的我们 若一切 都已云烟成雨 我能否 变成淤泥 再一次 沾染你 若生命 如过场电影 Oh 让我再一次 甜梦里惊醒 我多想再见你 哪怕匆匆一眼就别离 路灯下昏黄的剪影 越走越漫长的林径 我多想再见你 至少玩笑话还能说起 街巷初次落叶的秋分 渐行渐远去的我们 站台 汽笛响起 想念是你的声音 我们提着过去 走入人群 寻找着一个位置 安放自己 我多想再见你 哪怕匆匆一眼就别离 路灯下昏黄的剪影 越走越漫长的林径 我多想再见你 至少玩笑话还能说起 街巷初次落叶的秋分 渐行渐远去的我们]]></content>
      <categories>
        <category>民谣</category>
      </categories>
      <tags>
        <tag>民谣</tag>
        <tag>美歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跺码归福家田]]></title>
    <url>%2F2019%2F04%2F07%2F%E8%B7%BA%E7%A0%81%E5%BD%92%E7%A6%8F%E5%AE%B6%E7%94%B0%2F</url>
    <content type="text"><![CDATA[孔雀东南飞，五里一徘徊. 我行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，却只爱过一个正当最好年龄的人。 所谓美丽鸡鸣外欲曙，新妇起严妆。著我绣夹裙，事事四五通。足下蹑丝履，头上玳瑁光。腰若流纨素，耳著明月珰。指如削葱根，口如含朱丹。纤纤作细步，精妙世无双。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F07%2F%E7%A6%8F%E5%AE%B6%E7%94%B0Hello-World%2F</url>
    <content type="text"><![CDATA[这是我的第一个 Hexo 页面 此页面是第一个 Hexo 的第一个页面，仅留作纪念 福家田]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>关于</tag>
      </tags>
  </entry>
</search>
